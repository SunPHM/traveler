<<<<<<< HEAD
				<!DOCTYPE html>
				<html>
				<head>
					<meta content="text/html;charset=utf-8" http-equiv="Content-Type">
					<meta content="utf-8" http-equiv="encoding">
				  	<title>Walk with the miles</title>
					<link rel="stylesheet" type="text/css" href="css/tr.css">
				</head>

				<body background="image/Background-gray.jpg">
					<div id="canvas-container">
			   		<canvas id="myCanvas" width="500" height="40">
					</div>

					
						

					<!--javascript library -->
					<script src="js/three.js"></script>
					<script src="js/Detector.js"></script>
					<script src="js/d3.v3.min.js"></script>
				        <script src="js/d3.geo.projection.v0.min.js"></script>
				        <script src = "js/opentip-jquery.js"></script>

					<!--script main function -->
					<script>
						
						// Canvas for displaying the poem
						var canvas, context;

						//Varibles holding the quadrants
						var firstQuadrant,secondQuadrant,thirdQuadrant,fourthQuadrant, centre;
						var source ="NA"; //Source is english by default
						// when the mouse moves, call the given function
				      		document.addEventListener( 'mousemove', onDocumentMouseMove, false );
						// D3 variables for projecting the maps
						var projection, path, group;
						
						canvas = document.getElementById('myCanvas');
				      	context = canvas.getContext('2d');
						
						initD3();
						setQuadrants(source);


						// init D3
						function initD3(){
							var width = window.innerWidth, height = window.innerHeight;
							var color = d3.scale.category10();
							// create a svg graphic to show the maps of countries
							var svg = d3.select("body").append("svg").attr("width",width).attr("height",height);
							// add a projection function to move certain map to the center of the html page
							projection = d3.geo.mercator().scale(width / 6).translate([width / 2, height / 2]);
							// the path function translates GEOJson objects into svg path data
							path = d3.geo.path().projection(projection);
							// tranform the GEOJson object into svg path data and display it into html
							d3.json("maps/NA.geo.json", function(data)
							{
								group = svg.append("g").attr("id","group");
								group.selectAll("path").data(data.features).enter().append("path").attr("d",path);

							});
						}

						// set the center map of D3
						function setCenterMap(country, project){
							var width = window.innerWidth; 
							var height = 400;
							
									d3.json("maps/"+country+".geo.json", function(data)
									{
										// create a first guess for the projection
									      var center = d3.geo.centroid(data)
									      var scale  = 150;
									      var offset = [width/2, height/2];

											projection = eval("d3.geo."+project+"();").scale(scale).center(center).translate(offset);
						        			path = d3.geo.path().projection(projection);

					        				// using the path determine the bounds of the current map and use 
									      	// these to determine better values for the scale and translation
											      var bounds  = path.bounds(data);
											      var hscale  = scale*width  / (bounds[1][0] - bounds[0][0]);
											      var vscale  = scale*height / (bounds[1][1] - bounds[0][1]);
											      var scale   = (hscale < vscale) ? hscale : vscale;
											      var offset  = [width - (bounds[0][0] + bounds[1][0])/2,
											                        height - (bounds[0][1] + bounds[1][1])/2];

									     projection = eval("d3.geo."+project+"();")
	        												.center(center).scale(scale).translate(offset);;
									     path = path.projection(projection);


									     group.selectAll("path").data(data.features).enter().append("path").attr("d",path);
									     group.selectAll("path").transition().duration(300).attr("d", path);
										
									});
						}

						// A utility function to draw a rectangle with rounded corners.
						function roundedRect(context,x,y,width,height,radius,text,color){
						  context.beginPath();
						  context.moveTo(x,y+radius);
						  context.lineTo(x,y+height-radius);
						  context.quadraticCurveTo(x,y+height,x+radius,y+height);
						  context.lineTo(x+width-radius,y+height);
						  context.quadraticCurveTo(x+width,y+height,x+width,y+height-radius);
						  context.lineTo(x+width,y+radius);
						  context.quadraticCurveTo(x+width,y,x+width-radius,y);
						  context.lineTo(x+radius,y);
						  context.quadraticCurveTo(x,y,x,y+radius);
						  context.strokeStyle = "rgba(255, 255, 255, 0.5)";
						  context.stroke();
						  context.fillStyle = "rgba(255, 255, 255, 0.5)";
						  context.fill();

							// Create gradient
							var gradient = context.createLinearGradient(0, 0, canvas.width, 0);
							gradient.addColorStop("0", color);
							gradient.addColorStop("0.5", color);
							gradient.addColorStop("1.0", color);
							
							// Fill with gradient
							context.font="30px Georgia"
							context.fillStyle = gradient;
							context.fillText(text, 10, 25);
						}

						// capture mouse movement and update the ThreeJS scene
						function onDocumentMouseMove(event)
						{
							// update the mouse variable
							var mouse = {x:0, y:0};
							mouse.x = event.clientX;
							mouse.y = event.clientY;
							//console.log('mouse position captured: x = '  + mouse.x + ', y = ' + mouse.y);
							update(mouse);
						}
						
						function setQuadrants(source)
						{
							switch(source)
							{
								case "NA":
									firstQuadrant = "CHN";
									secondQuadrant="RUS";
									thirdQuadrant = "ARA";
									fourthQuadrant = "IND";
									centre = "NA";
									break;
								case "CHN":
									firstQuadrant = "RUS";
									secondQuadrant="NA";
									thirdQuadrant = "ARA";
									fourthQuadrant = "IND";
									centre = "CHN";
									break;
								case "RUS":
									firstQuadrant = "CHN";
									secondQuadrant="NA";
									thirdQuadrant = "ARA";
									fourthQuadrant = "IND";
									centre = "RUS";
									break;
								case "ARA":
									firstQuadrant = "CHN";
									secondQuadrant="RUS";
									thirdQuadrant = "NA";
									fourthQuadrant = "IND";
									centre = "ARA";
									break;
								case "IND":
									firstQuadrant = "CHN";
									secondQuadrant="RUS";
									thirdQuadrant = "NA";
									fourthQuadrant = "ARA";
									centre = "IND";
									break;
							}

						}



						// update the text to show at the mouse position
						function update(mouse){
							// x and y used for testing different languages
							var x = (mouse.x / window.innerWidth) * 2 - 1;
							var y = -(mouse.y / window.innerHeight) * 2 + 1;

							

										// origin
				                        if(((x>=-0.3) && (x<=0.3)) && ((y>=-0.3)&&(y<=0.3))){
				                                setCenterMap(centre,"mercator");
				                                message = "Two wrongs don't make a right";
				                                color = "#1E90FF"//Blue
				                        }
				                        // 1st quadrant
				                        else if(((x>0.3) && (x<=0.6)) && ((y>=0) &&(y<=0.3))){
				                                setCenterMap(firstQuadrant,"stereographic");
				                                 message = "两个错误不能 make a right";
				                         		color = "#FF0000"; //Red
				                        }

				                        else if(((x>=0.6) && (x<=1)) && ((y>=0) &&(y<=0.3))){
				                                setCenterMap(firstQuadrant,"stereographic");
				                                 message = "来得容易，去得快。";
				                                 color = "#FF0000"; //Red
				                        }

				                        else if(((x>=0.3) && (x<=1)) && ((y>=0) &&(y<=1))){
				                                setCenterMap(firstQuadrant,"homolosine");
				                                 message = "Два заблуждения не 作出正确的";
				                                color ="#800000";//Maroon
				                        }
				                        // 2nd quadrant
			                          else if(((x<=0.3) && (x>=-1) && (y<=1) && (y>=0)))
			                          {
			                                  setCenterMap(secondQuadrant,"homolosine");
			                                   message = "Два заблуждения не делают право";
			                                   color ="#800000";
			                          }
				                        else if(((x<=0.3) && (x>=-1) && (y<1) && (y>=0)))
				                        {
				                                setCenterMap(secondQuadrant,"mercator");
				                                 message = "two заблуждения не делают right";
				                                 color ="#800000";
				                        }

				                         // 3rd quadrant
				                        else if(((x>=-1) && (x<=0)) && ((y>=-1) && (y<=0)))
				                        {
				                                setCenterMap(thirdQuadrant,"mercator");
				                                 message = "ﺕﺄﺘﻳ ﻢﻧ ﺎﻠﺴﻬﻟ، ﻢﻧ ﺎﻠﺴﻬﻟ ﺎﻟﺬﻫﺎﺑ.";
				                                 //color = '#006600';
				                                 color = '#990066'; //Light Green
				                        }

				                        // 4th quadrant
				                        else if(((x<=1) && (x>=0)) && ((y>=-1) && (y<=0)))
				                        {
				                                setCenterMap(fourthQuadrant,"mercator");
				                                 message = "आसान में आओ, आसान जाओ।";
				                                 

				                                  color = '#FF0000'; //Yellow
				                        }
				                       
				                        else{
				                                 message = "test";
				                        }

							//Clear the textbox
							context.clearRect(0,0,640,600);
				            var metrics = context.measureText(message);
				            var width = metrics.width;
				            //Draw the textbox
				            roundedRect(context,x,y,width + 20,20+10,15,message,color);

						}
					</script>
				</body>
				</html>
=======
	<!DOCTYPE html>
	<html>
	<head>
		<meta content="text/html;charset=utf-8" http-equiv="Content-Type">
		<meta content="utf-8" http-equiv="encoding">
	  	<title>traveler</title>
		<link rel="stylesheet" type="text/css" href="css/tr.css">
	</head>

	<body>
		<div id="ThreeJS" style="position: absolute; left:0px; top:0px"></div>

		<!--javascript library -->
		<script src="js/three.js"></script>
		<script src="js/Detector.js"></script>
		<script src="js/d3.v3.min.js"></script>
	        <script src="js/d3.geo.projection.v0.min.js"></script>
	        <script src = "js/opentip-jquery.js"></script>

		<!--script main function -->
		<script>
			// ThreeJS global variables for rendering the scene
			var scene, camer, renderer;
			// ThreeJS variables for showing text, a plane facing towards the camera in 3-D space
			var canvas, context, texture, sprite;
			// when the mouse moves, call the given function
	      		//document.addEventListener( 'mousemove', onDocumentMouseMove, false );
			// D3 variables for projecting the maps
			var projection, path, group;
			//var center = ""; // the initial center for the map
			// init and animate
			initD3();
			initThreeJS();
			animate();
			// when the mouse moves, call the given function
                        document.addEventListener( 'mousemove', onDocumentMouseMove, false );
			//initD3();

			// init D3
			function initD3(){
				var width = window.innerWidth, height = window.innerHeight;
				// create a svg graphic to show the maps of countries
				var svg = d3.select("body").append("svg").attr("width",width).attr("height",height);
				// add a projection function to move certain map to the center of the html page
				projection = d3.geo.mercator().scale(width / 6).translate([width / 2, height / 2]);
				// the path function translates GEOJson objects into svg path data
				path = d3.geo.path().projection(projection);
				// tranform the GEOJson object into svg path data and display it into html
				console.log(window.center);
				d3.json("maps/" + window.center + ".geo.json", function(data)
				{
					group = svg.append("g").attr("id","group");
					//group.selectAll("path").data(data.features).enter().append("path").attr("d",path);
					var centroid = path.centroid(data),
					translate = projection.translate();
					projection.translate([translate[0] - centroid[0] + width / 2, translate[1] - centroid[1] + height / 2]);
					group.selectAll("path").data(data.features).enter().append("path").attr("d",path);
					//group.selectAll("path").transition().duration(300).attr("d", path);

				});
			}

			// set the center map of D3
			function setCenterMap(country, project){
				var width = window.innerWidth, height = window.innerHeight;
        projection = eval("d3.geo."+project+"();");
        path = d3.geo.path().projection(projection);
        //projection = d3.geo.+project+().scale(width / 6).translate([width / 2, height / 2]);
				d3.json("maps/"+country+".geo.json", function(data)
				{
					var centroid = path.centroid(data),
					translate = projection.translate();
					projection.translate([translate[0] - centroid[0] + width / 2, translate[1] - centroid[1] + height / 2]);
					group.selectAll("path").data(data.features).enter().append("path").attr("d",path);
					group.selectAll("path").transition().duration(300).attr("d", path);
				});
			}

			//init threeJS
			function initThreeJS()
			{
				// scene
				scene = new THREE.Scene();
				// camera
				var width = window.innerWidth, height = window.innerHeight;
				var angle = 45, aspect = width / height, near = 0.1, far = 20000;
				camera = new THREE.PerspectiveCamera(angle, aspect, near, far);
				scene.add(camera);
				camera.position.set(0, 150, 400);
				camera.lookAt(scene.position);
				// renderer
				if ( Detector.webgl )
					renderer = new THREE.WebGLRenderer({antialias:true});
				else
					renderer = new THREE.CanvasRenderer();
				renderer.setSize(width, height);
				// set the ThreeJS scene in the same papge as the D3
				var container = document.getElementById('ThreeJS');
	      			container.appendChild( renderer.domElement );
				// canvas, context, texture, sprite
				canvas = document.createElement('canvas');
				canvas.width  = 400;
				canvas.height = 80;
	      			context = canvas.getContext('2d');
				//context.font = "Bold 20px Times ";
				//context.fillStyle = "rgba(0,0,0,1)";

				/*// Quadratric curves example
			    context.beginPath();
			    context.moveTo(75,25);
			    context.quadraticCurveTo(25,25,25,62.5);
			    context.quadraticCurveTo(25,100,50,100);
			    context.quadraticCurveTo(50,120,30,125);
			    context.quadraticCurveTo(60,120,65,100);
			    context.quadraticCurveTo(125,100,125,62.5);
			    context.quadraticCurveTo(125,25,75,25);
			    context.stroke();*/

				texture = new THREE.Texture(canvas);
				texture.needsUpdate = true;
				var spriteMaterial = new
					THREE.SpriteMaterial({map:texture, useScreenCoordinates:true, alignment:THREE.SpriteAlignment.topLeft});
				sprite = new THREE.Sprite(spriteMaterial);
				sprite.scale.set(300,100,1.0);
	      			sprite.position.set( 50, 50, 0 );
				scene.add(sprite);
			}

			// animate function using ThreeJS to render new interface
			function animate()
			{
				requestAnimationFrame(animate);
	  			renderer.render(scene, camera);
			}
			// A utility function to draw a rectangle with rounded corners.

			function roundedRect(context,x,y,width,height,radius,text,color){
			  context.beginPath();
			  context.moveTo(x,y+radius);
			  context.lineTo(x,y+height-radius);
			  context.quadraticCurveTo(x,y+height,x+radius,y+height);
			  context.lineTo(x+width-radius,y+height);
			  context.quadraticCurveTo(x+width,y+height,x+width,y+height-radius);
			  context.lineTo(x+width,y+radius);
			  context.quadraticCurveTo(x+width,y,x+width-radius,y);
			  context.lineTo(x+radius,y);
			  context.quadraticCurveTo(x,y,x,y+radius);
			  context.strokeStyle = color;
			  context.stroke();
			  context.fillStyle = color;
			  context.fill();
			  context.font="30px Georgia";
			  context.fillStyle = "white";
				context.fillText(text,10,25);
			}
			// capture mouse movement and update the ThreeJS scene
			function onDocumentMouseMove(event)
			{
				// update the mouse variable
				var mouse = {x:0, y:0};
				mouse.x = event.clientX;
				mouse.y = event.clientY;
				//console.log('mouse position captured: x = '  + mouse.x + ', y = ' + mouse.y);
				update(mouse);
			}

			// update the text to show at the mouse position
			function update(mouse){
				// x and y used for testing different languages
				var x = (mouse.x / window.innerWidth) * 2 - 1;
				var y = -(mouse.y / window.innerHeight) * 2 + 1;

				//Color of tool tip for different language
				var color = "black";

							// origin - English
	                        if(((x>=-0.3) && (x<=0.3)) && ((y>=-0.3)&&(y<=0.3))){
	                                setCenterMap("NA","mercator");
	                                message = "Two wrongs don't make a right";
	                                color = "#0000FF"; //Blue
	                        }
	                        // 1st quadrant - Chinese
	                        else if(((x>0.3) && (x<=0.6)) && ((y>=0) &&(y<=0.3))){
	                                setCenterMap("CHN","stereographic");
	                                 message = "两个错误不能 make a right";
	                                 color = '#FF0000'; //Yellow
	                        }

	                        else if(((x>=0.6) && (x<=1)) && ((y>=0) &&(y<=0.3))){
	                                setCenterMap("CHN","stereographic");
	                                 message = "来得容易，去得快。";
	                                 color = '#FF0000'; //Yellow
	                        }

	                        else if(((x>=0.3) && (x<=1)) && ((y>=0) &&(y<=1))){
	                                setCenterMap("CHN","homolosine");
	                                 message = "Два заблуждения не 作出正确的";
	                                 color = '#FF0000'; //Yellow
	                        }
	                        // 2nd quadrant - Russian
                          else if(((x<=0.3) && (x>=-1) && (y<=1) && (y>=0)))
                          {
                                  setCenterMap("RUS","homolosine");
                                   message = "Два заблуждения не делают право";
                                   color = '#990066'; //Light Green
                          }
	                        else if(((x<=0.3) && (x>=-1) && (y<1) && (y>=0)))
	                        {
	                                setCenterMap("RUS","mercator");
	                                 message = "two заблуждения не делают right";
	                                 color = '#990066'; //Light Green
	                        }

	                        // 3rd quadrant - Hindi
	                        else if(((x<=1) && (x>=0)) && ((y>=-1) && (y<=0))){
	                                setCenterMap("IND","mercator");
	                                 message = "आसान में आओ, आसान जाओ।";
	                                 color = '#FF9900'; //Blue
	                        }
	                        // 4th quadrant - Arabic
	                        else if(((x>=-1) && (x<=0)) && ((y>=-1) && (y<=0))){
	                                setCenterMap("ARA","mercator");
	                                 message = "ﺕﺄﺘﻳ ﻢﻧ ﺎﻠﺴﻬﻟ، ﻢﻧ ﺎﻠﺴﻬﻟ ﺎﻟﺬﻫﺎﺑ.";
	                                 color = '#006600';
	                        }
	                        else{
	                                 message = "test";
	                        }

				//Clear the textbox
				context.clearRect(0,0,640,480);
	            var metrics = context.measureText(message);
	            var width = metrics.width;
	            //Draw the textbox
	            roundedRect(context,x,y,width + 20,20+10,15,message,color);

	            texture.needsUpdate = true;
				// update the textbox position
				sprite.position.set(mouse.x, mouse.y - 20, 0 );
			}
		</script>
	</body>
	</html>
>>>>>>> 182d55c1e6f177b94ec51769c297db9fbe604967
